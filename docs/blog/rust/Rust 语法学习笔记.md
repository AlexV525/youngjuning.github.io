---
title: Rust 语法学习笔记
cover: https://i.loli.net/2021/02/13/xlQI48CR6LteNJV.png
order: 2
---

语言之间都有着类似的核心特性，比如变量、基本类型、函数、注释和控制流程等概念。但是每个语言有都有自己的独有概念，本文便是记录了我在学习 Rust 语法过程中遇到的 Rust 独有概念。

## 变量与可变性

Rust 中的变量默认是不可变的。Rust 语言提供这一概念是为了能够让你安全且方便地写出复杂、甚至是并行的代码。当然，Rust 也提供了让你可以使用可变变量的方法。

```rust
// main.rs
fn main() {
  let x = 5;
  println!("The value of x is: {}", x);
  x = 6;
  println!("The value of x is: {}", x)
}
```

`x = 6` 属于重复赋值，所以执行 `cargo run` 编译是不会通过的：

![](https://i.loli.net/2021/02/14/IkenxsTQMb98Cg5.png)

![](https://i.loli.net/2021/02/14/aBWsyYNLqzlKtic.png)

我们可以通过在声明的变量名称前添加 `mut` 关键字来使其可变。除了使变量的值可变，`mut` 还会向阅读代码的人暗示其他代码可能会改变这个变量的值。

## 常亮与变量的不同

1. 我们不能使用 `mut` 关键字来修饰一个变量。常量不仅是默认不可变的，它还总是不可变的。
2. 你需要使用 `const` 关键字而不是一个 `let` 关键字来声明一个常量。
3. 在声明的同时，你必须显式地标注值的类型。
4. 常量可以被声明在任何作用域中，甚至包括全局作用域。这在一个值需要被不同部分的代码共同引用时十分有用
5. 你只能将一个常量绑定到一个常量表达式上，而无法将一个函数的返回值，或其他需要在运行时计算的值绑定到常量上。

> 我们约定俗称地使用以下划线分割的全大写字母来命名一个常量，并在数值中插入下划线来提高可读性：`const MAX_POINTS: u32 = 100_000;`

## 隐藏

在 Rust 中，新声明的变量可以覆盖掉旧的同名变量，我们把这一现象描述为：第一个变量被第二个变量隐藏（shadow）了。这意味着我们随后使用这个名称时，它指向的将会是第二个变量。我们可以重复使用 `let` 关键字并分配以相同的名称来不断地隐藏变量：

```rust
fn main() {
    let x = 5;
    let x = x + 1;
    let x = x * 2;
    println!("The value of x is: {}", x)
}
```

如下图，我们可以看到 JavaScript 中并没有该特性：

![](https://i.loli.net/2021/02/14/R7YPiIpJBc4qvxU.png)

隐藏机制和变量声明为 `mut` 的不同：

1. 如果不是在使用 `let` 重新为这个变量赋值，则会导致编译错误。通过使用 `let`，我们可以对这个值执行一系列的变换操作，并允许这个变量在操作完成后保持自己的不可变性。
2. 由于重复使用 `let` 关键字会创建出新的变量，所以我们可以在复用变量名称的同时改变它的类型。

## 数据类型

![](https://youngjuning.js.org/xmind/rust/Rust%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png)

RUST 的编译器可以根据我们如何绑定、使用变量的值来自动推导出变量的类型。但在无法自动推导的场景，就必须显式地添加一个类型标注。

### 标量类型（scalar）

**标量**类型是单个值类型的统称。Rust 中内建了 4 种基础的标量类型：整数、浮点数、布尔值及字符。这类似于 JavaScript 中的基础类型。

#### 整数类型

整数是指那些没有小数部分的数字。

| 长度   | 有符号                 | 无符号            |
| ------ | ---------------------- | ----------------- |
| 8 bit  | i8（-128 到 127）      | u8（0 到 255）    |
| 16 bit | i16（-32768 到 32767） | u16（0 到 65535） |
| 32 bit | i32(默认)              | u32               |
| 64 bit | i64                    | u64               |
| arch   | isize                  | usize             |

> Isize 和 usize 是特殊的整数类型，它们的长度取决于程序运行的目标平台。在 64 位架构上，它们就是 64 位的，而在 32 位架构上，它们就是 32 位的。

> 可以使用 `_` 作为分隔符以方便读数，比如 `1_000`

如何选择：

- 如果拿不定注意，Rust 对于整数字面量默认推导类型 i32 通常就是一个很好的选择：它在大部分情况下都是运算速度最快的
- 较为特殊的两个整数类型 `usize` 和 `isize` 则主要用作某些集合的索引

#### 浮点数类型

- 单精度浮点数（`f32`）
- 双精度浮点数（`f64`）(默认)

> 由于在现代 CPU 中双精度和单精度的运行效率相差无几，却拥有更高的精读，所以在 Rust 中，默认会将浮点数字面量的类型推到为 f64。

```rust
fn main() {
  let x = 2.0; // f64

  let y: f32 = 3.0; // f32
}
```

#### 布尔值

和 Go 语言一样，Rust 的布尔类型只拥有两个可能的值：`true`和 `false`。相较于 Javascript 中`false`、`0`、 `NaN`、`''`、`null`、`undefined` 6 种都可以被转换成 `false` 真的是很节省脑容量。

```rust
fn main() {
  let t = true;
  let f: bool = false // 附带了显式类型标注的语句
}
```

#### 字符类型

在 Rust 中，`char` 类型被用于描述语言中最基础的单个字符。需要注意的是，`char` 类型使用单引号指定，而不同于字符串使用双引号指定。

### 复合类型（compound）

复合类型可以将多个不同类型的值组合为一个类型。Rust 提供了两种内置的基础复合类型：元组（tuple）和数组（array）。

#### 元组类型

- 元组可以将其他不同类型的多个值进行组合
- 元组拥有一个固定的长度，我们无法在声明结束后增加或减少其中的元素数量

**创建元组：**

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

- 把一些列值使用逗号分隔后放置到一对圆括号中
- 元组每个位置的值都有一个类型，这些类型不需要是相同的。

上面这段带来执行 `cargo run` 会有编译警告：

![](https://i.loli.net/2021/02/14/AsUPGiQLtgT84ZH.png)

意思是，如果你是故意声明一个 `unused variable`，那就给变量名加一个下划线前缀来忽略警告

**取值：**

1、解构（destructuring）：使用模式匹配来解构元组：

```rust
fn main() {
    let tup = (500, 6.4, 1);
    let (_x, y, _z) = tup;
    println!("The value of y is: {}", y);
}
```

2、通过索引并使用点号(`.`)来访问元组中的值：

```rust
fn main() {
  let x: (i32, f64, u8) = (500, 6.4, 1);
  let five_hundred = x.0;
  let six_point_four = x.1;
  let one = x.2;
}
```

#### 数组类型

**数组（array）**

- 与元组不同的是数组中的每一个元素都必须是相同的类型。
- Rust 中的数组拥有固定的长度，一旦声明就再也不能随意更改大小，这与其他语言不同。

在 Rust 中，你可以将以逗号分隔的值放置在一对方括号内来创建一个数组：

```rust
fn main() {
  let a = [1, 2, 3, 4, 5]
}
```

通常当你不想在栈上而不是堆上为数据分配空间时，或者想要确保总有固定数量的元素时，数组是一个非常有用的工具。

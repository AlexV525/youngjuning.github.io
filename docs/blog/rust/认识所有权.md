---
title: 认识所有权
order: 4
---

> 关于 Rust 是如何管理运行时内存的一章。

## 什么是所有权

一般来说，所有的程序都需要管理自己在运行时使用的计算机内存空间。某些使用垃圾回收机制的语言会在运行时定期检查并回收那些没有被继续使用的内存；而在另外一些语言中，程序员需要手动分配和释放内存。Rust 采用了与众不同的第三种方式：它使用包含特定规则的所有权系统来管理内存，这套规则允许编译器在编译过程中执行检查工作，而不会产生任何的运行时开销。

## 所有权规则

- Rust 中的每一个值都有一个对应的变量作为它的所有者.
- 在同一时间内，值有且仅有一个所有者。
- 当所有者离开自己的作用域时，它持有的值就会被释放掉。

## String

```rs
let mut s = String::from("hello");

s.push_str(", world!");

println!("{}", s);
```

- 调用 `from` 函数根据字符串字面量来创建一个 `String` 实例
- 双冒号（`::`）运算符允许我们调用至于 `String` 命名空间下面的特定 `from` 函数（关联函数）
- `push_str` 函数向 `String` 空间的尾部添加了一段字面量

> 字符串字面量是不可变的，因为存储在栈中的数据都必须拥有一个已知且固定的大小。
> `String` 是可变的，因为它是存储在堆上的。堆空间的管理是比较松散的：当你希望将数据放入堆中时，你就可以请求特定大小的空间。操作系统会根据你的请求在堆中找到一块足够大的可用空间，将它标记为已使用，并把指向这片空间地址的指针返回给我们。堆的大小原理上是不固定的。

## 内存与分配

> 与其他语言不同的是，Rust 提供了另一套解决方案：内存会自动地在拥有它的变量离开作用后进行释放。

对应 String 类型而言，为了支持一个可变的、可增长的文本类型，我们需要在堆上分配一块在编译时未知大小的内存来存放数据。这同时也意味着：

- 我们使用的内存是由操作系统在运行时动态分配出来的。
- 当使用完 String 时，我们需要通过某种方式将这些内存归还给操作系统。

```rust
{
    let s = String::from("hello"); // 从此处起，s 是有效的

    // 使用 s
}                                  // 此作用域已结束，
                                  // s 不再有效
```

### 变量与数据交互的方式

**1、移动（Move）**

假如你在其他语言中接触过浅度拷贝（shallow copy）和深度拷贝（deep copy）这两个术语，那么你也许会将这里复制指针、长度及容量字段的行为视作浅度拷贝。但由于 Rust 同时使第一个变量无效了，所以我们使用新的术语移动（move）来描述这一行为，而不再使用浅度拷贝。

> Rust 永远不会自动地创建数据的深度拷贝。因此在 Rust 中，任何自动的复制操作都可以被视为高效的。

2、克隆（clone）

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
}
```

- 当你确实需要去深度拷贝 String 堆上的数据，而不仅仅是栈数据时，就可以使用一个名为 `clone` 的方法。

**栈上数据的复制**

Rust 提供了一个名为 `Copy` 的 trait，它可以用于整数这类完全存储在栈上的数据类型。一旦某种数据类型拥有了 `Copy` 这种 trait，那么它的变量就可以在赋值给其他变量之后保持可用性。如果一种类型本身或这种类型的任意成员实现了 `Drop` 这种 trait，那么 Rust 就不允许其实现 `Copy` 这种 trait。尝试给某个需要在离开作用域时执行特殊指令的类型实现 `Copy` 这种 trait 会导致编译时错误。

下面是一些拥有 Copy 这种 trait 的类型：

- 所有的整数类型，诸如 `u32`
- 仅拥有两种值（`true` 和 `false`）的布尔类型：`bool`
- 字符类型：`char`
- 所有的浮点类型，诸如 `f64`
- 如果元组包含的所有字段的类型都是 `Copy` 的，那么这个元组也是 `Copy` 的。例如，`(i32, i32)` 是 `Copy` 的，但 `(i32, String)` 则不是

### 所有权和函数

```rust
fn main() {
    let s = String::from("hello"); // 变量 s 进入作用域

    takes_ownership(s); // s 的值被移动进了函数
                        // 所以它从这里开始不再有效

    let x = 5; // 变量 x 进入作用域
    makes_copy(x); // 变量 x 同样被传递进了函数
                   // 但由于 i32 是 Copy 的，所以我们依然可以在这之后使用 x。
} // x 首先离开作用域，随后是 s。
  // 但由于 s 的值已经发生了移动，所以没有什么特别的事情会发生。

fn takes_ownership(some_string: String) {
    // some_string 进入作用域
    println!("{}", some_string);
} // some_string 在这里离开作用域，drop 函数被自动调用，
  // some_string 所占用的内存也就随之被释放了

fn makes_copy(some_integer: i32) {
    // some_interger 进入作用域
    println!("{}", some_integer);
} // some_interger 在这里离开了作用域，没有什么特别的事情发生。
```
